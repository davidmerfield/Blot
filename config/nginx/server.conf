# Number of worker processes is set to the same as the number of CPUs.
# More is not useful?
worker_processes  4;

# Sets the limit of the maximum number of open files (RLIMIT_NOFILE) 
# for worker processes
worker_rlimit_nofile 10000;

error_log stderr;

pid /var/run/nginx.pid;

events {
    worker_connections 10000;
    multi_accept on;
}
http {

log_format access_log_format '[$time_local] $request_id $status $request_time $request_length:$bytes_sent $scheme://$host$request_uri  cache=$sent_http_blot_cache';

error_log /var/www/blot/logs/nginx.error.log info;
access_log /var/www/blot/logs/nginx.log access_log_format;

# Hide the nginx version in the server header
server_tokens off;

# Added to set the content-type charset header 
# for text files served by NGINX
charset utf-8;

# Taken from 
# https://github.com/h5bp/server-configs-nginx/blob/master/mime.types

types {

  # Data interchange

    application/atom+xml                  atom;
    application/json                      json map topojson;
    application/ld+json                   jsonld;
    application/rss+xml                   rss;
    application/vnd.geo+json              geojson;
    application/xml                       rdf xml;


  # JavaScript

    # Normalize to standard type.
    # https://tools.ietf.org/html/rfc4329#section-7.2
    application/javascript                js jsgzip;


  # Manifest files

    application/manifest+json             webmanifest;
    application/x-web-app-manifest+json   webapp;
    text/cache-manifest                   appcache;


  # Media files

    audio/midi                            mid midi kar;
    audio/mp4                             aac f4a f4b m4a;
    audio/mpeg                            mp3;
    audio/ogg                             oga ogg opus;
    audio/x-realaudio                     ra;
    audio/x-wav                           wav;
    image/bmp                             bmp;
    image/gif                             gif;
    image/jpeg                            jpeg jpg;
    image/jxr                             jxr hdp wdp;
    image/png                             png;
    image/svg+xml                         svg svggzip;
    image/tiff                            tif tiff;
    image/vnd.wap.wbmp                    wbmp;
    image/webp                            webp;
    image/x-jng                           jng;
    video/3gpp                            3gp 3gpp;
    video/mp4                             f4p f4v m4v mp4;
    video/mpeg                            mpeg mpg;
    video/ogg                             ogv;
    video/quicktime                       mov;
    video/webm                            webm;
    video/x-flv                           flv;
    video/x-mng                           mng;
    video/x-ms-asf                        asf asx;
    video/x-ms-wmv                        wmv;
    video/x-msvideo                       avi;

    # Serving `.ico` image files with a different media type
    # prevents Internet Explorer from displaying then as images:
    # https://github.com/h5bp/html5-boilerplate/commit/37b5fec090d00f38de64b591bcddcb205aadf8ee

    image/x-icon                          cur ico;


  # Microsoft Office

    application/msword                                                         doc;
    application/vnd.ms-excel                                                   xls;
    application/vnd.ms-powerpoint                                              ppt;
    application/vnd.openxmlformats-officedocument.wordprocessingml.document    docx;
    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet          xlsx;
    application/vnd.openxmlformats-officedocument.presentationml.presentation  pptx;


  # Web fonts

    application/font-woff                 woff;
    application/font-woff2                woff2;
    application/vnd.ms-fontobject         eot;

    # Browsers usually ignore the font media types and simply sniff
    # the bytes to figure out the font type.
    # https://mimesniff.spec.whatwg.org/#matching-a-font-type-pattern
    #
    # However, Blink and WebKit based browsers will show a warning
    # in the console if the following font types are served with any
    # other media types.

    application/x-font-ttf                ttc ttf;
    font/opentype                         otf;


  # Other

    application/java-archive              ear jar war;
    application/mac-binhex40              hqx;
    application/octet-stream              bin deb dll dmg exe img iso msi msm msp safariextz;
    application/pdf                       pdf;
    application/postscript                ai eps ps;
    application/rtf                       rtf;
    application/vnd.google-earth.kml+xml  kml;
    application/vnd.google-earth.kmz      kmz;
    application/vnd.wap.wmlc              wmlc;
    application/x-7z-compressed           7z;
    application/x-bb-appworld             bbaw;
    application/x-bittorrent              torrent;
    application/x-chrome-extension        crx;
    application/x-cocoa                   cco;
    application/x-java-archive-diff       jardiff;
    application/x-java-jnlp-file          jnlp;
    application/x-makeself                run;
    application/x-opera-extension         oex;
    application/x-perl                    pl pm;
    application/x-pilot                   pdb prc;
    application/x-rar-compressed          rar;
    application/x-redhat-package-manager  rpm;
    application/x-sea                     sea;
    application/x-shockwave-flash         swf;
    application/x-stuffit                 sit;
    application/x-tcl                     tcl tk;
    application/x-x509-ca-cert            crt der pem;
    application/x-xpinstall               xpi;
    application/xhtml+xml                 xhtml;
    application/xslt+xml                  xsl;
    application/zip                       zip;
    text/css                              css cssgzip;
    text/csv                              csv;
    text/html                             htm html shtml htmlgzip;
    text/markdown                         md;
    text/mathml                           mml;
    text/plain                            txt;
    text/vcard                            vcard vcf;
    text/vnd.rim.location.xloc            xloc;
    text/vnd.sun.j2me.app-descriptor      jad;
    text/vnd.wap.wml                      wml;
    text/vtt                              vtt;
    text/x-component                      htc;

}

open_file_cache          max=1000 inactive=3600s;
open_file_cache_valid    60s;
open_file_cache_min_uses 1;
open_file_cache_errors   on;

# do we get better performance if we disable this feature
# rather than resending the entire file?
# if_modified_since off;

sendfile on;
sendfile_max_chunk 1m;

tcp_nopush on;
tcp_nodelay on;

gzip on;
gzip_types text/plain text/xml text/css
           text/comma-separated-values
           application/javascript
           text/javascript application/x-javascript
           application/atom+xml;
upstream blot_node {
    server 127.0.0.1:8080;
    keepalive 64;
}

map $http_accept_encoding $gz {
  default "";
  ~*.*gzip.* gzip;
}
    

    server {
        listen 443 ssl http2;

        set $blot_host blot.development;
        set $blot_directory /var/www/blot;
        set $cache_directory /cache;

        # You can't use a variable in the server_name directive apparently
        server_name blot.development;

        ssl_certificate  /etc/blot/blot.development.crt;
        ssl_certificate_key /etc/blot/blot.development.key;

root /;

# Disable etags from NGINX
etag off;

# For some reason, I was only able to *reduce* 
# the client_max_body_size in location blocks
# rather than raise it, so we start by setting
# an extremely high max POST size here, then
# reduce it where needed in the locations below
client_max_body_size 1000M;

# The caching folders include the protocol in the path, so that redirects
# from HTTP to HTTP can be handled at the Node.js application. I figure
# this isn't important here so we have no protocol in the folder structure
# use $request_uri if you want the query string also
# use $uri if you don't want the query string
set $permanent_cache $cache_directory/$blot_host/$scheme/permanent$request_uri;
set $temporary_cache $cache_directory/$blot_host/$scheme/temporary$request_uri/index.html;

# Stores the files served at the CDN route
set $static_directory $blot_directory/static;

error_page 502 /error-proxy-502.html;

location = /error-proxy-502.html {
  client_max_body_size 1M;
  root  $blot_directory/app/views;
}

# This is used to determine whether the server is handling
# requests, don't remove it unless you change monit.rc too!
location = /health {
  client_max_body_size 1M;
  return 200;
}

# Example CDN url: https://blot.im/cdn/blog_xyz/_image/name.jpg
# needs everything after '/cdn' to be looked up inside the static
# files directory in /var/www/blot/static. It might be nice
# in future to use cdn.blot.im as the back-end so that we don't
# need this regex here to capture the path, we can just use the URI
# Previously we also looked up $permanent_cache but that doesn't make
# any sense to me â€“ is there a reason to do that?
location ~ /cdn(.*)$ {
  add_header 'Blot-Cache' 'true-cdn' always;
  add_header 'Cache-Control' 'public, max-age=31536000' always;
  add_header 'Access-Control-Allow-Origin' '*';
  client_max_body_size 1M;
  gzip on;
  try_files $static_directory$1 @permanent_cache;
}

# location ~* \.(jpg|jpeg|gif|css|png|svg|js|ico|json|xml|txt|woff2|woff|eot|ttf|mp4)$ {
#   add_header 'Blot-Cache' 'true-permanent-gzip' always;
#   add_header 'Cache-Control' 'public, max-age=31536000' always;
#   add_header 'Access-Control-Allow-Origin' '*';
#   add_header 'Content-Encoding' 'gzip';
#   client_max_body_size 1M;
#   gzip off;
#   try_files $permanent_cache$gz @permanent_cache;  
# }

# This is used to prevent people from accessing the git repositories in user folders
# We basically pass these requests directly to the node server where they are treated
# as 404s. This needs to be in both blot-blog.conf and blot-site.conf because it seems
# all requests hit the blot-site.conf cache layer first?
location ^~ /.git {
add_header 'Blot-Cache' proxied$because_dashboard always;

proxy_pass http://blot_node;
proxy_http_version 1.1;

proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-Request-ID $request_id;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';

# This seemed to fix an issue with MP4 demo video
# ERR_CONTENT_DECODING_FAILED
# All gzipping should be handled by NGINX, rather than node
proxy_set_header Accept-Encoding "";

proxy_redirect off;

}

# location @permanent_cache_gzip {
#   add_header 'Blot-Cache' 'true-permanent-gzip' always;
#   add_header 'Cache-Control' 'public, max-age=31536000' always;
#   add_header 'Access-Control-Allow-Origin' '*';
#   add_header 'Content-Encoding' 'gzip';
#   client_max_body_size 1M;
#   # We have pre-compressed this file if it exists
#   gzip off;
#   try_files $permanent_cache$gz @permanent_cache;  
# }

location @permanent_cache {
  add_header 'Blot-Cache' 'true-permanent' always;
  add_header 'Cache-Control' 'public, max-age=31536000' always;
  add_header 'Access-Control-Allow-Origin' '*';
  client_max_body_size 1M;
  gzip on;
  try_files $permanent_cache @temporary_cache;  
}


# This is where we send server-sent events
# which need a long timeout
location = /status {
  client_max_body_size 1M;  
  proxy_read_timeout 24h;
add_header 'Blot-Cache' proxied$because_dashboard always;

proxy_pass http://blot_node;
proxy_http_version 1.1;

proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-Request-ID $request_id;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';

# This seemed to fix an issue with MP4 demo video
# ERR_CONTENT_DECODING_FAILED
# All gzipping should be handled by NGINX, rather than node
proxy_set_header Accept-Encoding "";

proxy_redirect off;

}

# Allow uploads of files up to 250mb for the importer
# and for the photo upload page. I'd like to make this
# specific in future with a nice regex
location /dashboard/ {
  client_max_body_size 250M;
  set $because_dashboard '-because-dashboard';  
add_header 'Blot-Cache' proxied$because_dashboard always;

proxy_pass http://blot_node;
proxy_http_version 1.1;

proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-Request-ID $request_id;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';

# This seemed to fix an issue with MP4 demo video
# ERR_CONTENT_DECODING_FAILED
# All gzipping should be handled by NGINX, rather than node
proxy_set_header Accept-Encoding "";

proxy_redirect off;

}

# We want the people using the git client to be able to 
# make large commits but perhaps we rate limit them 
# to make sure the server isn't locked up?
location /clients/git/end/ {
  client_max_body_size 1000M;
  # will only affect pulls, since you can't limit upload rate by default
  # use this to limit pushes
  # https://www.nginx.com/resources/wiki/modules/upload/
  limit_rate_after 100M;
  # sets max download speed to 100 Kbps
  limit_rate 5M; 
add_header 'Blot-Cache' proxied$because_dashboard always;

proxy_pass http://blot_node;
proxy_http_version 1.1;

proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-Request-ID $request_id;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';

# This seemed to fix an issue with MP4 demo video
# ERR_CONTENT_DECODING_FAILED
# All gzipping should be handled by NGINX, rather than node
proxy_set_header Accept-Encoding "";

proxy_redirect off;

}

location / {
  add_header 'Blot-Cache' 'true-temporary-gzip' always;
  add_header 'Cache-Control' 'no-cache' always;
  add_header 'Content-Encoding' 'gzip';
  client_max_body_size 1M;
  # We have pre-compressed this file if it exists
  gzip off;
  open_file_cache off;
  try_files @permanent_cache @blot;  
}

location @temporary_cache {
  add_header 'Blot-Cache' 'true-temporary' always;
  add_header 'Cache-Control' 'no-cache' always;
  client_max_body_size 1M;
  gzip on;
  open_file_cache off;
  try_files $temporary_cache @blot;  
}

location @blot {
  client_max_body_size 1M;
  gzip on;
add_header 'Blot-Cache' proxied$because_dashboard always;

proxy_pass http://blot_node;
proxy_http_version 1.1;

proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-Request-ID $request_id;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';

# This seemed to fix an issue with MP4 demo video
# ERR_CONTENT_DECODING_FAILED
# All gzipping should be handled by NGINX, rather than node
proxy_set_header Accept-Encoding "";

proxy_redirect off;

}    }

    server {
        listen 80;
        server_name blot.development; 
        return 301 https://$host$request_uri;
    }

    server {
        listen 80 default_server;
        listen 443 ssl http2 default_server;

        set $blot_directory /var/www/blot;
        set $cache_directory /cache;

        ssl_certificate  /etc/blot/blot.development.crt;
        ssl_certificate_key /etc/blot/blot.development.key;

root /;

# This is used to determine whether the server is handling
# requests, don't remove it unless you change monit.rc too!
location = /health {
  return 200;
}

error_page 502 /error-proxy-502.html;

# send the text '502 Bad Gateway' to the client
location = /error-proxy-502.html {
  client_max_body_size 1M;
  root  $blot_directory/app/views;
}

# The caching folders include the protocol in the path, so that redirects
# from HTTP to HTTP can be handled at the Node.js application. 
# Use $request_uri if you want the query string also
# use $uri if you don't want the query string
set $permanent_cache $cache_directory/$host/$scheme/permanent$request_uri;

set $temporary_cache $cache_directory/$host/$scheme/temporary$request_uri;
set $temporary_cache_index $cache_directory/$host/$scheme/temporary$request_uri/index.html;

set $static $cache_directory/$host/static$request_uri;
set $blog_folder $cache_directory/$host/folder$request_uri;

location / {
  add_header 'Blot-Cache' 'true-cache-permanent' always;
  add_header 'Cache-Control' 'public, max-age=31536000' always;
  try_files $permanent_cache @static;
}

location @static {
  add_header 'Blot-Cache' 'true-static' always;
  add_header 'Cache-Control' 'public, max-age=31536000' always;
  try_files $static @temporary;
}

location @temporary {
  open_file_cache off;
  default_type text/html;
  add_header 'Cache-Control' 'no-cache' always;
  add_header 'Blot-Cache' 'true-cache-temporary' always;
  try_files $temporary_cache $temporary_cache_index @blog_folder;
}

location @blog_folder {
  open_file_cache off;
  add_header 'Cache-Control' 'no-cache' always;
  add_header 'Blot-Cache' 'true-blog-folder' always;
  try_files $blog_folder @blot;
}

location @blot {
  add_header 'Blot-Cache' 'false' always;
add_header 'Blot-Cache' proxied$because_dashboard always;

proxy_pass http://blot_node;
proxy_http_version 1.1;

proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-Request-ID $request_id;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';

# This seemed to fix an issue with MP4 demo video
# ERR_CONTENT_DECODING_FAILED
# All gzipping should be handled by NGINX, rather than node
proxy_set_header Accept-Encoding "";

proxy_redirect off;

}

# This is used to prevent people from accessing the git repositories in user folders
# We basically pass these requests directly to the node server where they are treated
# as 404s. This needs to be in both blot-blog.conf and blot-site.conf because it seems
# all requests hit the blot-site.conf cache layer first?
location ^~ /.git {
add_header 'Blot-Cache' proxied$because_dashboard always;

proxy_pass http://blot_node;
proxy_http_version 1.1;

proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;
proxy_set_header X-Request-ID $request_id;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection 'upgrade';

# This seemed to fix an issue with MP4 demo video
# ERR_CONTENT_DECODING_FAILED
# All gzipping should be handled by NGINX, rather than node
proxy_set_header Accept-Encoding "";

proxy_redirect off;

}
    }    
}